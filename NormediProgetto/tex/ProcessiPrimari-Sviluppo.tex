\documentclass[../NomeDocumento.tex]{subfiles}

\begin{document}
	
% NORME DI PROGETTO -> PROCESSI PRIMARI -> SVILUPPO

\section{Sviluppo}

\subsection{Scopo}

Il processo di sviluppo ha il fine di pianificare dettagliatamente e poi realizzare le attività che il gruppo di lavoro deve svolgere per fornire il prodotto richiesto dal capitolato.

\subsection{Descrizione}

Per una corretta implementazione di tale processo le aspettative sono le seguenti:

\begin{itemize}
	\item realizzare un prodotto finale \glossario{conforme}{conforme} alle richieste del proponente;
	\item realizzare un prodotto finale soddisfacente i test di verifica;
	\item realizzare un prodotto finale soddisfacente i test di validazione;
	\item fissare gli obiettivi di \glossario{sviluppo}{sviluppo};
	\item fissare i vincoli tecnologici;
	\item fissare i vincoli di design.
\end{itemize}

\noindent Il processo di sviluppo si svolge in accordo con lo standard ISO/IEC 12207, pertanto si compone delle seguenti attività:

\begin{itemize}
	\item Analisi dei requisiti
	\item Progettazione
	\item Codifica
\end{itemize}

\subsection{Analisi dei Requisiti}

	\subsubsection{Scopo} 
	
	Gli \glossario{Analisti}{analista} devono individuare ed elencare i \glossario{requisiti}{requisito} del progetto da realizzare.
	
	\subsubsection{Descrizione}
	
	I requisiti devono essere estratti dal capitolato d’appalto, dai verbali di riunione e dallo studio dei casi d’uso. Il documento \textit{Analisi dei Requisiti} deve:
	
	\begin{itemize}
		\item Descrivere il fine del progetto;
		\item Fissare le funzionalità e i requisiti richiesti dal committente;
		\item Definire tecniche di raffinamento e di miglioramento del prodotto e processo di sviluppo;
		\item Definire tecniche per la revisione del codice;
		\item Fornire ai \glossario{Verificatori}{verificatore} indicazioni per le attività di test.
		\item Definire una stima dei costi.
	\end{itemize}

	\noindent Durante l’Analisi dei Requisiti gli \textit{Analisti} analizzano individualmente le varie fonti, quindi, a seguito di una riunione, si confrontano e stilano le varie liste di requisiti suddivise per importanza. Le fonti per gli \textit{Analisti} sono:
	 
	\begin{itemize}
		\item \textbf{Capitolato d’appalto:} requisiti emersi dall’analisi del documento fornito dal committente;
		\item \textbf{Verbali esterni:} requisiti emersi a seguito di colloqui con i responsabili dell’azienda committente;
		\item \textbf{Casi d'uso:} requisiti emersi a seguito di uno o più casi d’uso analizzati.
		\item \textbf{Tracciabilità Interna (TI):} requisiti emersi tramite discussioni ed incontri tra gli \textit{Analisti} del gruppo Graphite;
	\end{itemize}

	\subsubsection{Classificazione requisiti} 
	
	I requisiti devono essere suddivisi per importanza e classificati come segue:
	
	\begin{center}
		R[Importanza][Tipologia][Codice]
	\end{center}
	
		\begin{itemize}
			\item \textbf{Importanza:} Ogni requisito può appartenere solo ad una delle classi di Importanza elencate di seguito:
			\begin{itemize}
				\item \textbf{O (Requisito Obbligatorio):} requisito fondamentale per la corretta realizzazione del progetto;
				\item \textbf{D (Requisito Desiderabile):} requisito non fondamentale al progetto ma il cui soddisfacimento comporterebbe una maggiore completezza del prodotto;
				\item \textbf{F (Requisito Facoltativo):} requisito non richiesto per il corretto funzionamento del prodotto ma che se incluso arricchirebbe il progetto. Prima di soddisfare il requisito è necessaria un’analisi di tempi e costi per evitare ritardi nella consegna e/o costi superiori a quelli preventivati.
			\end{itemize}
			\item \textbf{Tipologia:} Di seguito sono riportate le tipologie di requisito:
			\begin{itemize}
				\item \textbf{V:} Identifica un \glossario{requisito di vincolo}{requisito di vincolo};
				\item \textbf{F:} Identifica un \glossario{requisito funzionale}{requisito funzionale};
				\item \textbf{P:} Identifica un \glossario{requisito prestazionale}{requisito prestazionale};
				\item \textbf{Q:} Identifica un \glossario{requisito di qualità}{requisito di qualita}.
			\end{itemize}
		\item \textbf{Codice:} Ogni requisito è formato da un codice numerico che lo indentifica in modo univoco.
		\end{itemize}
	
	\noindent Il codice stabilito secondo la convenzione precedente, una volta associato ad un requisito, non potrà cambiare nel tempo.
	
	\noindent Ciascun requisito dovrà inoltre essere accompagnato dalle sue fonti, dalle sue relazioni di dipendenza con altri requisiti e da una descrizione che ne specifichi lo scopo. Sarà inoltre indicata l'importanza.
	
	
	%immagine esempio di tabella dei requisiti
	
		
	\subsubsection{Classificazione casi d’uso} 
	
	I \glossario{casi d'uso}{caso d'uso} verranno identificati nel seguente modo: 
	
	\begin{center}
		UC[Codice padre]*.[Codice identificativo]
	\end{center}
	
	\begin{itemize}
		\item \textbf{Codice padre:} identifica il codice del caso d'uso da cui è stato generato il caso d'uso identificato, se non esiste il campo va tralasciato;
		\item \textbf{Codice identificativo:} identifica il caso d'uso univocamente.
	\end{itemize}

	\noindent Ogni caso d'uso è inoltre definito secondo la seguente struttura:
	\begin{itemize}
		\item \textbf{ID:} il codice del caso d'uso secondo la convenzione specificata precedentemente;
		\item \textbf{Nome:} specifica il titolo del caso d'uso;
		\item \textbf{Attori:} indica gli attori principali (ad esempio l'utente generico) e secondari (ad esempio entità di autenticazione esterne) del caso d'uso;
		\item \textbf{Descrizione:} riporta una breve descrizione del caso d'uso;
		\item \textbf{Precondizione:} specifica le condizioni che sono identificate come vere prima del verificarsi degli eventi del caso d'uso;
		\item \textbf{Postcondizione:} specifica le condizioni che sono identificate come vere dopo il verificarsi degli eventi del caso d'uso;
		\item \textbf{Scenario principale:} rappresenta il flusso degli eventi come lista numerata, specificando per ciascun evento: titolo, descrizione, attori coinvolti e casi d'uso generati;
		\item \textbf{Scenari Alternativi:} specifica casi di errore o eventi non previsti nel flusso di esecuzione;
		\item \textbf{Inclusioni:} usate per non descrivere più volte lo stesso flusso di eventi, inserendo il comportamento comune in un caso d'uso a parte;
		\item \textbf{Estensioni:} descrivono i casi d'uso che non fanno parte del flusso principale degli eventi, allo stesso modo di quanto descritto in "Scenario principale".
	\end{itemize}

	Alcuni casi d'uso possono essere associati ad un Diagramma \glossario{UML}{UML} 2.x dei casi d'uso riportante lo stesso titolo e codice.

	
	\centerline{Esempio di caso d'uso:}	% questa deve diventare la caption dell'immagine
	
	%immagine esempio di caso d'uso
	
\subsection{Progettazione} 

	\subsubsection{Scopo} 

	L'attività di Progettazione deve obbligatoriamente precedere la produzione del software e consiste nel descrivere una soluzione del problema che sia soddisfacente per tutti gli \glossario{stakeholders}{stakeholders}.
	
	\subsubsection{Descrizione}
	
	Essa serve a garantire che il prodotto sviluppato soddisfi le proprietà e i bisogni specificati nell'attività di analisi. La progettazione permette di:
	
	\begin{itemize}
		\item Costruire un’architettura logica del prodotto;
		\item Ottimizzare l’uso delle risorse;
		\item Garantire una determinata qualità del prodotto, perseguendo la \textit{correttezza per costruzione}: è questo il principio secondo il quale il software deve funzionare correttamente e soddisfare tutti i requisiti e i vincoli perché è stato progettato per farlo e per essere conforme ed \glossario{efficace}{efficacia}. Si trova in netta contrapposizione alla \textit{correttezza per
		correzione};
		\item Organizzare e dividere le parti del progetto in modo da poter ottenere componenti singole e facili da implementare attraverso la codifica. 
	\end{itemize}

	E' compito dei \textit{Progettisti} svolgere l'attività di Progettazione, definendo l'architettura logica del prodotto identificando componenti chiare, riusabili e coese, rimanendo nei costi fissati. L'architettura definita deve attenersi alle seguenti qualità:
	\begin{itemize}
		\item \textbf{Sufficienza:} soddisfare i requisiti definiti nel documento \textit{Analisi dei Requisiti};
		\item \textbf{Comprensibilità:} essere capita dagli stakeholders e quindi descritta in modo comprensibile, oltre ad essere tracciabile sui requisiti;
		\item \textbf{Modularità:} essere divisa in parti chiare e distinte, ognuna con la sua specifica funzione;
		\item \textbf{Robustezza:} essere in grado di gestire malfunzionamenti in modo da rimanere operativa di fronte a situazioni erronee improvvise;
		\item \textbf{Flessibilità:} permettere modifiche a costo contenuto nel caso in cui i requisiti dovessero evolversi o se ne dovessero aggiungere di nuovi;
		\item \textbf{Riusabilità:} essere costruita in modo da poter permettere il riutilizzo di alcune sue parti;
		\item \textbf{Efficienza:} soddisfare tutti i requisiti in modo tale da ridurre gli sprechi di tempo e spazio;
		\item \textbf{Affidabilità:} garantire che i servizi esposti siano sempre disponibili, ovvero svolgere i suoi compiti quando viene usata;
		\item \textbf{Disponibilità:} necessitare di tempo ridotto per la manutenzione in modo da garantire un servizio il più continuo possibile;
		\item \textbf{Sicurezza:} essere sicura rispetto ad intrusioni e malfunzionamenti;
		\item \textbf{Semplicità:} prediligere la semplicità, contenendo solo il necessario, rispetto ad una inutile complessità;
		\item \textbf{Incapsulazione:} fare in modo che l'interno delle componenti non sia visibile dall'esterno, seguendo il principio del \glossario{data hiding}{data hiding};
		\item \textbf{Coesione:} raggruppare le parti secondo l'obiettivo a cui concorrono, in modo da avere maggiore manutenibilità e riusabilità;
		\item \textbf{Basso accoppiamento:} non avere dipendenze indesiderabili.
	\end{itemize}

	\subsubsection{Design Patterns}
	
	Finita l'attività di Analisi, è compito dei \textit{Progettisti} adottare opportune soluzioni progettuali a problemi ricorrenti. Tali soluzioni devono essere flessibili e consentire una certa libertà d'uso ai \textit{Programmatori}. Per ogni \glossario{Design Pattern}{Design Pattern} utilizzato, esso va riportato all'interno del documento di \textit{Specifica Tecnica} riportando un diagramma che lo illustri e una descrizione testuale inerente la sua applicazione e utilità all'interno dell'architettura.
	
	\subsubsection{UML 2.0}
	
		Al fine di rendere più chiare le scelte progettuali adottate e ridurre le possibili ambiguità, è necessario fare largo uso di vari tipi di diagrammi UML 2.0, tra cui:
	
	\begin{itemize}
		\item \textbf{Diagrammi delle classi:} definiscono relazioni, metodi e attributi di classi e tipi, astraendosi da un qualsiasi linguaggio di programmazione;
		\item \textbf{Diagrammi dei \glossario{package}{package}:} illustrano raggruppamenti di classi che condividono la stessa causa di cambiamento e necessitano di essere riusate assieme;
		\item \textbf{Diagrammi di sequenza:} servono a descrivere le interazioni che avvengono fra gli oggetti che devono implementare collettivamente un comportamento, rappresentando sequenze di azioni tramite scelte definite (ad esempio, una sequenza di invocazioni tra metodi);
		\item \textbf{Diagrammi delle attività:} descrivono il flusso di operazioni di una attività (ad esempio un algoritmo), descrivendone la logica procedurale.
	\end{itemize}

	\noindent E' possibile inoltre fare uso di altre tipologie di diagrammi, come diagrammi delle componenti, di macchine a stati o di \glossario{deployment}{deployment}, se necessario.
	
	\subsection{Codifica}
	
	\subsubsection{Scopo}
	
	Nella seguente sezione sono riporte le norme da seguire durante la programmazione da parte dei \textit{Programmatori}. Lo scopo di queste norme consiste nel dare delle linee guida in modo tale che il codice risulti leggibile e aiuti durante la fase di mantenimento, verifica e validazione, migliorando così la qualità del prodotto.

	\subsubsection{Descrizione}
	
	Aderiremo alle GNU GCC Coding Conventions che si trovano all'indirizzo \url{https://gcc.gnu.org/codingconventions.html}. 
	
	\subsubsection{Formattazione}
	
	Le convenzioni di formattazione principalmente saranno le seguenti:
	
	\begin{itemize}
		
		\item \textbf{Linee:} Le linee devono essere al massimo di 80 colonne;
		
		\item \textbf{Nomi:} I nomi delle macro dovrebbero essere tutti in maiuscolo nei casi in cui è importante essere consapevoli che è una macro, ma quando creiamo un \glossario{wrapper}{wrapper} per l'efficienza, in cui fondamentalmente vogliamo far finta che sia una funzione, dovrebbe essere in minuscolo. Ad esempio, size\textunderscore int è una macro.\\
		Quando le strutture e/o le classi hanno funzioni membro, è preferito nominare i dati membro con il prefisso m\textunderscore , mentre per i dati statici con il prefisso s\textunderscore .\\
		I nomi dei parametri dei template dovrebbero usare \glossario{CamelCase}{CamelCase}, seguendo lo standard C++.\\
		Altri nomi dovrebbero essere minuscoli e separati dal trattino basso;
		
		\item \textbf{Espressioni:}
		\begin{center}
		\begin{tabular}{|l|c|c|}
			\hline
			Per&Uso...&...invece di \\ \hline
			not logico&!x&! x \\ \hline
			complemento bit a bit&${\sim}x$&$\sim x$ \\ \hline
			meno unario&-x&- x \\ \hline
			conversione esplicita&(foo) x&(foo)x \\ \hline
			deferenziazione puntatore&*x&* x \\ \hline
		\end{tabular}
		\end{center}
		
		\item \textbf{Variabili:} Le variabili dovrebbero essere definite nel momento del loro primo utilizzo, piuttosto che nella parte superiore della funzione. Le variabili possono essere definite e testate simultaneamente nelle espressioni di controllo;
		
		\item \textbf{Strutture:} Utilizzare la parola chiave struct per i semplici vecchi dati (\glossario{POD}{POD});
		
		\item \textbf{Classi:} Usare la parola chiave class per i tipi non POD.	
		Un tipo non POD spesso ha una dichiarazione di una funzione membro speciale.		
		È consentita l'ereditarietà singola. Utilizzare l'ereditarietà pubblica per l'interfaccia, cioè le relazioni 'is-a'. Utilizzare l'ereditarietà privata e protetta per l'implementazione. L'ereditarietà nell'implementazione può essere utile, ma da rifletterci prima di usarla in codice destinato a durare a lungo.		
		Le gerarchie complesse devono essere evitate. Fare particolare attenzione con l'ereditarietà multipla. Nella rara occasione in cui l'utilizzo dell'ereditarietà multipla è davvero utile fare particolare attenzione a rendere chiara la documentazione dell'intera gerarchia.		
		Pensare attentamente alle dimensioni e all'impatto sulle prestazioni delle funzioni prima di utilizzarle.		
		E' preferito rendere privati i membri dei dati.
		
		Per la definizione di classe usare le seguenti regole:
		
		\begin{itemize}
			\item Non indentare etichette di protezione;
			\item Indentare i membri della classe di due spazi;
			\item Se possibile scrivere l'intera classe su una singola riga.
				
				\begin{verbatim}
					class gnuclass: base {
				\end{verbatim}
					
				Altrimenti, iniziare con i due punti dell'elenco all'inizio della riga successiva.
				
				\begin{verbatim}
				class a_rather_long_class_name
				: with_a_very_long_base_name, and_another_just_to_make_life_hard
				{
				  int member;
				};
				\end{verbatim}
					
			\item Se l'elenco supera una riga, spostare gli inizializzatori traboccanti sulla riga successiva con il rientro di due spazi.
				
				\begin{verbatim}
				class gnuclass
				: base1 <template_argument1>, base2 <template_argument1>,
				  base3 <template_argument1>, base4 <template_argument1>
				{
				  int member;
				};
				\end{verbatim}
		\end{itemize}
		
		Quando si definisce una classe l'ordine in cui definire i suoi elementi dovrebbe essere questo:
					
		\begin{itemize}
			\item definire tutti i tipi pubblici;
			\item definire tutti i tipi non pubblici;
			\item dichiarare tutti i costruttori pubblici;
			\item dichiarare il distruttore pubblico;
			\item dichiarare tutte le funzioni dei membri pubblici;
			\item dichiarare tutte le variabili membro pubbliche;
			\item dichiarare tutti i costruttori non pubblici;
			\item dichiarare il distruttore non pubblico;
			\item dichiarare tutte le funzioni di membro non pubblico;
			\item dichiarare tutte le variabili membro non pubbliche.				
		\end{itemize}
			
		Se vincoli semantici richiedono un diverso ordine di dichiarazione, cercare di minimizzare la potenziale confusione.
			
		Chiudere una definizione di classe con parentesi graffa destra, punto e virgola, commento di chiusura facoltativo e una nuova riga.
			
		\begin{verbatim}
		}; // class gnuclass
		\end{verbatim}
		
		\item \textbf{Membri di una classe:} Definire tutti i membri al di fuori della definizione della classe, cioè non ci sono corpi di funzioni o inizializzatori di membri all'interno della definizione di classe.
		
		E' preferito scrivere tutto su una singola riga.
		
		\begin{verbatim}
		gnuclass::gnuclass () : base_class ()
		{ 
		  ...
		};
		\end{verbatim}
		
		Quando ciò non è possibile, posiziona i due punti della lista di inizializzatori all'inizio di una riga.
		
		\begin{verbatim}
		gnuclass::gnuclass ()
		: base1 (), base2 (), member1 (), member2 (), member3 (), member4 ()
		{ 
		  ...
		};
		\end{verbatim}
		
		Se la lista di inizializzazione supera una riga, sposta gli inizializzatori traboccanti sulla riga successiva e il rientro di due spazi.
		
		\begin{verbatim}
		gnuclass::gnuclass ()
		: base1 (some_expression), base2 (another_expression),
		  member1 (my_expressions_everywhere)
		{ 
		  ...
		};
		\end{verbatim}
		
		Se il nome di una funzione C++ è abbastanza lungo da far sì che il primo parametro di funzione con il suo tipo superi 80 caratteri, dovrebbe apparire nella riga successiva di quattro spazi rientrati.
		
		\begin{verbatim}
		void
		very_long_class_name::very_long_function_name (
		    very_long_type_name arg)
		{
		\end{verbatim}
		
		A volte il qualificatore della classe e il nome della funzione insieme superano gli 80 caratteri. In questo caso, interrompi la riga prima dell'operatore ::. Potremmo desiderare di farlo in modo preventivo per tutte le funzioni dei membri della classe.
		
		\begin{verbatim}
		void
		very_long_template_class_name <with, a, great, many, arguments>
		::very_long_function_name (
		    very_long_type_name arg)
		{
		\end{verbatim}		
		
		\item \textbf{Costruttori:} Tutti i costruttori devono inizializzare i membri dei dati nell'elenco di inizializzazione dei membri piuttosto che nel corpo del costruttore;
		
		\item \textbf{Distruttori:} Una classe con funzioni virtuali dovrebbe avere un distruttore virtuale;
		
		\item \textbf{Conversioni:} I costruttori a singolo argomento dovrebbero essere quasi sempre dichiarati espliciti.		
		Gli operatori di conversione dovrebbero essere evitati;
		
		\item \textbf{Overloading delle funzioni:} È consentito fare \glossario{overloading}{overloading} delle funzioni, facendo però in modo che non siano inaspettati, cioè semanticamente identici o almeno molto simili. Non è consigliato farlo per le funzioni virtuali;
		
		\item \textbf{Overloading degli operatori:} È consentito fare overloading degli operatori, facendo però in modo che non siano inaspettati. Un uso non inaspettato è quello dei tipi numerici nell'implementazione. L'overloading degli operatori, ad eccezione dell'operatore di chiamata, non deve essere utilizzato per implementazioni costose;
		
		\item \textbf{Argomenti di default:} Gli argomenti di default sono un altro tipo di overloading di funzioni e si applicano le stesse regole. Gli argomenti di default devono sempre essere valori POD, cioè non possono eseguire costruttori. Le funzioni virtuali non dovrebbero avere argomenti di default;
		
		\item \textbf{Funzioni inline:} Costruttori e distruttori, anche quelli con corpi vuoti, sono spesso molto più grandi di quanto si aspettino i \textit{Programmatori}. Preferire versioni non in linea a meno che non si abbia la prova che la versione in linea sia più piccola o abbia un impatto significativo sulle prestazioni;
		
		\item \textbf{Template:} Per evitare dimensioni eccessive del compilatore, prendere in considerazione l'implementazione di template non banali su una classe base non template con parametri void*.
		Una dichiarazione che segue un elenco di parametri del template non dovrebbe avere indentazione aggiuntiva.
		E' preferito il typename sulla classe nella lista di parametri del template;
		
		
		\item \textbf{Namespace:} I namespace sono incoraggiati. Tutte le librerie separabili dovrebbero avere un unico namespace globale. I nomi delle directory annidate devono essere associati a namespace annidati quando possibile.		
		I file header non dovrebbero avere direttive using.
		
		Aprire un namespace con il nome seguito da una parentesi graffa sinistra e una nuova riga.
		
		\begin{verbatim}
		namespace gnutool {
		\end{verbatim}
		
		Chiudere con una parentesi graffa destra, un commento di chiusura facoltativo e una nuova riga.		
		
		\begin{verbatim}
		} // namespace gnutool
		\end{verbatim}
		
		Le definizioni all'interno del corpo di un namespace non sono indentate;
		
		\item \textbf{Extern:} E' preferito un blocco extern a un qualificatore di dichiarazione.
		
		Aprire un blocco extern con la parentesi graffa sinistra sulla stessa riga.
		
		\begin{verbatim}
		extern "C" {
		\end{verbatim}
		
		Chiudere con una parentesi destra, un commento di chiusura opzionale e una nuova riga.
		
		\begin{verbatim}
		} // extern "C"
		\end{verbatim}
		
		Le definizioni all'interno del corpo di un blocco extern non sono indentate.
	
	\end{itemize}
	
\end{document}